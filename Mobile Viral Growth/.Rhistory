journal.test<-data.frame(Mood=c(9,17), Activity=c(10,9), Company=c(4,3), Situation=c(1,1), Thinking=c(2,1), Public=c(1,2), Time=c(9,7))
journal.model.rf = randomForest(Mood ~ Activity+Company+Situation+Thinking+Public+Time, data=journal.train, ntree=501, mtry=6, importance=TRUE)
journal.test$pred.mood.rf = predict(journal.model.rf, journal.test, type="response")
#table(journal.test$Mood, journal.test$pred.mood.rf);
prop.table(table(journal.test$Mood, journal.test$pred.mood.rf),1)
library(randomForest)
journal.train <- read.csv("~/Documents/R Scripts/journal_train2.csv")
journal.test<-data.frame(Mood=c('Tired','Interested'), Activity=c(10,9), Company=c(4,3), Situation=c(1,1), Thinking=c(2,1), Public=c(1,2), Time=c(9,7))
journal.model.rf = randomForest(Mood ~ Activity+Company+Situation+Thinking+Public+Time, data=journal.train, ntree=501, mtry=6, importance=TRUE)
journal.test$pred.mood.rf = predict(journal.model.rf, journal.test, type="response")
#table(journal.test$Mood, journal.test$pred.mood.rf);
prop.table(table(journal.test$Mood, journal.test$pred.mood.rf),1)
msgs <- read.csv("~/Desktop/mobile_agg_msgs.csv")
View(msgs)
View(msgs)
hist(msgs$avg_daily_msgs,breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs,breaks = 500,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs,breaks = 5000,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs,breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98),breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
> hist(cf$V1[order(cf
$V1)][1:floor(length(sf
$V1)*0.98)],breaks = 50,col = 3, freq=TRUE, main = 'Swoon # of Facebook Friends', xlab = 'Friends', ylab='# of Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98),breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 50,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 200,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 300,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 300,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 500,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 1000,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 100,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 100,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Messages', ylab='Users')
tab <- table(msgs$avg_daily_msgs)
tab2 <- as.data.frame(cbind(as.integer(names(tab)), as.integer(tab)))
str(tab2)
plot(log(tab2$V1 ), log(tab2$V2 ), type = "l", lwd = 3, xlab="Log of msg count",ylab="Log of # of users", main="Log-Log of # Msgs Per User")
View(msgs)
msgs <- read.csv("~/Desktop/mobile_agg_msgs.csv")
hist(msgs$avg_daily_msgs[order(msgs$avg_daily_msgs)][1:floor(length(msgs$avg_daily_msgs)*0.98)],breaks = 100,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Avg Messages per Day', ylab='Users')
tab <- table(msgs$avg_daily_msgs)
tab2 <- as.data.frame(cbind(as.integer(names(tab)), as.integer(tab)))
str(tab2)
plot(log(tab2$V1 ), log(tab2$V2 ), type = "l", lwd = 3, xlab="Log of msg count",ylab="Log of # of users", main="Log-Log of # Msgs Per User")
hist(msgs$median_daily_msgs[order(msgs$median_daily_msgs)][1:floor(length(msgs$median_daily_msgs)*0.98)],breaks = 100,col = 3, freq=TRUE, main = 'Tagged iOS Users', xlab = 'Median Messages per Day', ylab='Users')
tab <- table(msgs$median_daily_msgs)
tab2 <- as.data.frame(cbind(as.integer(names(tab)), as.integer(tab)))
str(tab2)
plot(log(tab2$V1 ), log(tab2$V2 ), type = "l", lwd = 3, xlab="Log of msg count",ylab="Log of # of users", main="Log-Log of # Msgs Per User")
msgs<-msgs[2:4]
View(msgs)
msgs<-msgs[1:3]
View(msgs)
msgs <- read.csv("~/Desktop/mobile_agg_msgs.csv")
m<-msgs[1:3]
m<-msgs[1:2]
View(m)
m<-msgs[2:3]
View(m)
summary(msgs)
install.packages("rserve")
install.packages("Rserve")
library(Rserve)
help(Rserve)
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
# args <- '{"prods":["IBM","YHOO","MSFT"]}';
# res <- getOptimalPortfolio(args)
# fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
# args <- '{"prods":["IBM","YHOO","MSFT"]}';
# res <- getOptimalPortfolio(args)
# fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
fix(getOptimalPortfolio)
fix(getOptimalPortfolio)
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
args <- '{"prods":["IBM","YHOO","MSFT"]}';
res <- getOptimalPortfolio(args)
fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
args <- '{"prods":["IBM","YHOO","MSFT"]}';
res <- getOptimalPortfolio(args)
#fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
getOptimalPortfolio(args)
args
getOptimalPortfolio(args)
library(RJSONIO)
install.packages("RJSONIO")
getOptimalPortfolio(args)
library(RJSONIO)
install.packages("tseries")
getOptimalPortfolio(args)
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
# args <- '{"prods":["IBM","YHOO","MSFT"]}';
# res <- getOptimalPortfolio(args)
# fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
require(tseries)
require(RJSONIO)
hackZeroes <- function (x) {
for (i in which(x == 0)) {
if (i == 1) {
c = i
while (x[c] == 0) {
c = c + 1
}
x[i] <- x[c]
} else {
x[i] <- x[i - 1]
}
}
x
}
getReturns <- function (symbol) {
assetPrice <- as.vector(get.hist.quote(symbol,
start="2009-8-6", end="2011-8-6",
compression="w", quote="Close", quiet=TRUE))
assetPrice <- hackZeroes(assetPrice)
assetReturns <- diff(log(assetPrice[1:(length(assetPrice)-1)]))
return(assetReturns)
}
getOptimalPortfolio <- function (jsonObj) {
x <- c()
o = fromJSON(jsonObj)
symbols <- o$prods
for (asset in symbols) {
rets = getReturns(asset);
x <- cbind(x, rets)
}
# Target Return (pm) is weekly
res <- portfolio.optim(x, pm = mean(x),
reslow = c(0, 0, 0), reshigh = c(1, 1, 1))
return(toJSON(res))
}
args <- '{"prods":["IBM","YHOO","MSFT"]}';
res <- getOptimalPortfolio(args)
fromJSON(res)$pw
# Optimal weights: 0.27107,0.2688,0.46013
set.seed(8675309)
A <- rnorm(100, 10)
B <- rnorm(100, 15)
fit <- t.test(A, B)
print(fit)
set.seed(8675309)
A <- rnorm(100, 10)
B <- rnorm(100, 11)
fit <- t.test(A, B)
print(fit)
set.seed(8675309)
A <- runif(100, 10)
B <- rnorm(100, 11)
fit <- t.test(A, B)
print(fit)
help(runif)
set.seed(8675309)
A <- runif(100)
B <- rnorm(100, 11)
fit <- t.test(A, B)
print(fit)
set.seed(8675309)
A <- runif(100)
B <- rnorm(100, 11)
fit <- t.test(A, B)
print(fit)
set.seed(8675309)
A <- runif(100)
B <- runif(100)
fit <- t.test(A, B)
print(fit)
# Runs a logistic regression to estimate the fit of different features for contact closeness
# vote outcome model
# Updated: Helena Buhr (June 10, 2013)
#---------
# Set up
#---------
# Remove old data
delete_old <- function()
rm(list=ls(pos=.GlobalEnv), pos=.GlobalEnv)
delete_old()
ls()
# Set working directory
directory_path <- '/Users/shill/documents/R scripts/Mobile Viral Growth'
setwd(directory_path) # set working directory
getwd() # verify working directory
# Open click datafiles and zip code data (sepate files for zip code data)
dat <- read.table("contact_data.csv", header = TRUE, sep = ",") #  read data
summary(dat)
#areaCode
#vote Other (=0), Friend (=1), Family (=2)
#lastCallDateTime
#timeCalled
#textMsgs
#callFreq
#starred
#hasPhoto
#isFirstName
#callRecency
#areaCodeDist
#
#dat<-subset(dat, dat$gender=="F")
# Select which version to test
#dat$vote <- ifelse(dat$vote == "2" | dat$vote == "1", 1,0) #combine friend and family
#dat$vote <- ifelse(dat$vote == "2", 1,0) #just family
dat$friend <- ifelse(dat$vote == "1", 1,0) #just friend
dat$friend <- ordered(dat$friend,
levels = c(0,1),
labels = c("Not Friend", "Friend"))
dat$family <- ifelse(dat$vote == "2", 1,0)
dat$outcome <- ordered(dat$vote,
levels = c(0,1, 2),
labels = c("Other", "Friend", "Family"))
# Descriptives by user
descriptives <- table(dat$testSubject, dat$friend)
descriptives <- cbind(descriptives, descriptives[,2] / (descriptives[,2] + descriptives[,1]),  (descriptives[,2] + descriptives[,1]))
par(mfrow=c(1,2))
plot( descriptives[,4],  descriptives[,2] , xlab = "Total Contacts", ylab = "Friends")
abline(lm(descriptives[,2] ~ descriptives[,4]) , col = 'red', lty = 2)
plot(descriptives[,4] ,  descriptives[,3] , xlab = "Total Contacts", ylab = " % Friends in contact list") # share friends
abline(lm(descriptives[,3] ~ descriptives[,4]), col = 'red', lty = 2)
# Descriptives for friends / non friends
# Text vs calls : Exclude zero values
callFreqfriends <- table(dat$callFreq, dat$friend)
par(mfrow=c(1,2))
datSub <- subset(dat, dat$callFreq > 0 ) # Exclude zero values
boxplot(log(datSub$callFreq + 1)  ~ datSub$outcome, ylab="Call Frequncy", main = "Calls (zero values excl.)")
datSub <- subset(dat, dat$textMsgs > 0 ) # Exclude zero values
boxplot(log(datSub$textMsgs + 1)  ~ datSub$outcome, ylab="Text Frequncy", main = "Text (zero values excl.)")
# Text vs calls
par(mfrow=c(1,2))
plot(dat$callFreq , dat$textMsgs , xlab = "Text messages", ylab = " Calls") # share friends
abline(lm(dat$textMsgs ~ dat$callFreq), col = 'red', lty = 2)
plot(log(dat$callFreq +1) , log(dat$textMsgs + 1) , xlab = "Text messages (log)", ylab = " Calls (log)") # share friends
abline(lm(log(dat$textMsgs + 1)  ~ log(dat$callFreq + 1) ), col = 'red', lty = 2)
# Text to call ratio
par(mfrow=c(1,1))
dat$text2cal <-  dat$textMsgs /  (dat$callFreq + 1)
boxplot( log(dat$text2cal + 1)  ~dat$outcome, ylab="Text / call ratio (logged)", main = "Text / call ratio (logged)")
par(mfrow=c(1,3))
hist(log(subset(dat, dat$vote == 0)$text2cal + 1), main = "Other", xlab = "Text to call ratio (logged)")
hist(log(subset(dat, dat$vote == 1)$text2cal + 1), main = "Friends",  xlab = "Text to call ratio (logged)")
hist(log(subset(dat, dat$vote == 2)$text2cal + 1), main = "Family",  xlab = "Text to call ratio (logged)")
# People without any contacts
dat$textMsgsBinary <- ifelse(dat$textMsgs > 0, 1, 0)
textBinary <- table(dat$outcome, dat$textMsgsBinary)
textBinary <- cbind(textBinary, (textBinary[,2] / (textBinary[,1] + textBinary[,2] )  ))
barplot(textBinary[,3], main = "Text", ylab = "Fraction with at least one text msg")
dat$callFreqBinary <- ifelse(dat$callFreq > 0, 1, 0)
callBinary <- table(dat$outcome, dat$callFreqBinary)
callBinary <- cbind(callBinary, (callBinary[,2] / (callBinary[,1] + callBinary[,2] )  ))
barplot(callBinary[,3], main = "Calls", ylab = "Fraction with at least one call")
# What does it mean if you text and not call and vice versa
par(mfrow=c(2,2))
# no text and no call
dat$noTextnoCall <- ifelse(dat$textMsgsBinary == 0 & dat$callFreqBinary == 0, 1, 0)
temp <- table(dat$outcome, dat$noTextnoCall)
temp <- cbind(temp, (temp[,2] / (temp[,1] + temp[,2] )  ))
barplot(temp[,3], main = "No Text & No Call", ylab = "Fraction of users")
rm(temp)
# Call and no text
dat$noTextCall <- ifelse(dat$textMsgsBinary == 0 & dat$callFreqBinary == 1, 1, 0)
temp <- table(dat$outcome, dat$noTextCall)
temp <- cbind(temp, (temp[,2] / (temp[,1] + temp[,2] )  ))
barplot(temp[,3], main = "No Text, but Call", ylab = "Fraction of users")
rm(temp)
# Text and no call
dat$TextNoCall <- ifelse(dat$textMsgsBinary == 1 & dat$callFreqBinary == 0, 1, 0)
temp <- table(dat$outcome, dat$TextNoCall)
temp <- cbind(temp, (temp[,2] / (temp[,1] + temp[,2] )  ))
barplot(temp[,3], main = "Text, but No Call", ylab = "Fraction of users")
rm(temp)
# Text and call
dat$TextCall <- ifelse(dat$textMsgsBinary == 1 & dat$callFreqBinary == 1, 1, 0)
temp <- table(dat$outcome, dat$TextCall)
temp <- cbind(temp, (temp[,2] / (temp[,1] + temp[,2] )  ))
barplot(temp[,3], main = "Text & Call", ylab = "Fraction of users")
rm(temp)
# Correlations between text and calls
par(mfrow=c(1,2))
plot(dat$callFreq, dat$textMsgs, xlab = "Calls", ylab = "Text msgs")
abline(lm(dat$textMsgs ~ dat$callFreq), col = 'red', lty = 2)
plot(log(dat$callFreq + 1), log(dat$textMsgs + 1), xlab = "Calls (logged)", ylab = "Text msgs (logged)")
abline(lm(log(dat$textMsgs + 1) ~ log(dat$callFreq + 1)), col = 'red', lty = 2)
dat$starred <- ifelse(dat$starred == 1, 1,0) #fill in missing false values
dat$hasPhoto <- ifelse(dat$hasPhoto == 1, 1,0) #fill in missing false values
# Descriptive statistics
summary(dat)
#-------------------
# Subset the data set
# Exclude family since they will be excluded with other rules
#--------------
dat <- subset(dat, dat$family == 0)
#--------------
# Baseline model
#---------
M0 <- with(dat, glm(vote ~ 1
, family=binomial("logit")))
summary(M0)
M0_likelihood <- with(M0,
y * log(fitted.values) + (1 - y) * log(1 - fitted.values) )
mean(M0_likelihood)
#--------------
# Add features
#----------------
# callFreq   + callFreqBinary
# log(textMsgs + 1) + textMsgsBinary
M1 <- with(dat, glm(vote ~ textMsgs  + textMsgsBinary  +hasPhoto + starred
, family=binomial("logit")))
summary(M1)
M1_likelihood <- with(M1,
y * log(fitted.values) + (1 - y) * log(1 - fitted.values) )
mean(M1_likelihood)
dat$fitted <- ifelse(M1$fitted < 0.5, 0, 1)
table(dat$fitted, dat$friend)
#--------------
# No text data
#----------------
# callFreq   + callFreqBinary
# log(textMsgs + 1) + textMsgsBinary
M1 <- with(dat, glm(vote ~  hasPhoto + starred
, family=binomial("logit")))
summary(M1)
M1_likelihood <- with(M1,
y * log(fitted.values) + (1 - y) * log(1 - fitted.values) )
mean(M1_likelihood)
dat$fitted <- ifelse(M1$fitted < 0.5, 0, 1)
table(dat$fitted, dat$friend)
View(dat)
dat <- read.table("contact_data.csv", header = TRUE, sep = ",") #  read data
dat <- subset(dat, dat$gender == "M")
